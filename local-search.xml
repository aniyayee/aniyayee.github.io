<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Miscellaneous</title>
    <link href="/2023/09/11/Miscellaneous/"/>
    <url>/2023/09/11/Miscellaneous/</url>
    
    <content type="html"><![CDATA[<h1 id="一、使用devtools实现远程热部署"><a href="#一、使用devtools实现远程热部署" class="headerlink" title="一、使用devtools实现远程热部署"></a>一、使用devtools实现远程热部署</h1><h2 id="1-实现过程"><a href="#1-实现过程" class="headerlink" title="1 实现过程"></a>1 实现过程</h2><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1 配置"></a>1.1 配置</h3><ul><li>pom 依赖</li></ul><p><img src="/../img/image-20230909123938399.png"></p><p><img src="/../img/image-20230909123919643.png"></p><ul><li>yml 配置</li></ul><p><img src="/../img/image-20230909123710887.png"></p><ul><li>Configurations</li></ul><p><img src="/../img/image-20230909124210393.png"></p><h3 id="1-2-具体操作"><a href="#1-2-具体操作" class="headerlink" title="1.2 具体操作"></a>1.2 具体操作</h3><ul><li>修改方法体</li></ul><p><img src="/../img/image-20230909124404772.png"></p><ul><li>Recompile</li></ul><p><img src="/../img/image-20230909124609910.png"></p><h2 id="2-实现现象"><a href="#2-实现现象" class="headerlink" title="2 实现现象"></a>2 实现现象</h2><h3 id="2-1-本地IDEA"><a href="#2-1-本地IDEA" class="headerlink" title="2.1 本地IDEA"></a>2.1 本地IDEA</h3><p><img src="/../img/1694417656730.jpg"></p><h3 id="2-2-远程服务器"><a href="#2-2-远程服务器" class="headerlink" title="2.2 远程服务器"></a>2.2 远程服务器</h3><ul><li>本地 Recompile 前，调用 GET &#x2F;captcha&#x2F;{phone}</li></ul><p><img src="/../img/image-20230909123113261.png"></p><ul><li>本地 Recompile 后，远程服务器经过两次重启，调用 GET &#x2F;captcha&#x2F;{phone}</li></ul><p><img src="/../img/image-20230909125022034.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Linux</title>
    <link href="/2023/09/07/rookie-Linux/"/>
    <url>/2023/09/07/rookie-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查询 java 进程</span><br>$ jps<br><br>$ ps -ef| grep java<br><br><span class="hljs-comment"># 销毁进程</span><br>$ <span class="hljs-built_in">kill</span> -9 [PID]<br><br><span class="hljs-comment"># 运行 jar</span><br>$ <span class="hljs-built_in">nohup</span> java -jar xxx.jar &amp;<br><br><span class="hljs-comment"># 查看日志</span><br>$ <span class="hljs-built_in">tail</span> -1000f nohup.out<br><br><span class="hljs-comment"># 删除文件</span><br>$ <span class="hljs-built_in">rm</span> -rf [filename]<br></code></pre></td></tr></table></figure><h1 id="Advance"><a href="#Advance" class="headerlink" title="Advance"></a>Advance</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 class md5</span><br>$ <span class="hljs-built_in">md5sum</span> xxx.class<br><br><span class="hljs-comment"># 非 FatJar 启动</span><br>$ java -<span class="hljs-built_in">cp</span> ./lib/*:./classes/ com.rookie.Application<br><br><span class="hljs-comment"># 监听端口</span><br>$ netstat -ant| grep 3306<br><span class="hljs-comment">#外部地址 </span><br>Proto Recv-Q Send-Q Local Address           Foreign Address         State <br><br><span class="hljs-comment"># 查看 hosts</span><br>$ <span class="hljs-built_in">cat</span> /etc/hosts<br><br><span class="hljs-comment"># 查看网络服务</span><br>$ telnet PATH [端口]<br><br><span class="hljs-comment"># 查找文件 当前目录及其子目录</span><br>$ find . -iname  <span class="hljs-string">&quot;hello.jar&quot;</span><br><br><span class="hljs-comment"># 复制到 /tmp 便于运维删除</span><br>$ <span class="hljs-built_in">cp</span> hello.jar /tmp<br><br><span class="hljs-comment"># 查看端口/进程相关信息</span><br>$ ss -tnlp| grep [端口/进程]<br><br>$ netstat -tnlp| grep [端口/进程]<br><br><span class="hljs-comment"># 生成文件夹</span><br>$ <span class="hljs-built_in">mkdir</span> foldername<br><br><span class="hljs-comment"># 生成文件</span><br>$ <span class="hljs-built_in">touch</span> filename<br><br><span class="hljs-comment"># 查看工作目录下的内容</span><br>$ <span class="hljs-built_in">ls</span> -ltr<br><br><span class="hljs-comment"># 使用指定的JDK运行 jar</span><br>$ <span class="hljs-built_in">nohup</span> [openjdk]/bin/java -jar xxx.jar &amp;<br><br><span class="hljs-comment"># 远程服务器文件复制 将本机目录下的所有内容拷贝到远程目录下</span><br>$ scp -r /home/local_directory/* username@server_ip:/home/remote_directory/<br><br><span class="hljs-comment"># 添加执行权限</span><br>$ <span class="hljs-built_in">chmod</span> +x xxx.sh<br></code></pre></td></tr></table></figure><h2 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h2><blockquote><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示通信过程</span><br>$ curl -v www.ip.com<br>$ curl --trace output.txt www.ip.com<br>$ curl --trace-ascii output.txt www.ip.com<br><br><span class="hljs-comment"># GET请求</span><br>$ curl -v https://www.example.com<br><br><span class="hljs-comment"># POST请求 &quot;-X POST&quot;可以省略 Content-Type: application/x-www-form-urlencoded</span><br>$ curl -X POST -d <span class="hljs-string">&quot;captcha=abcd&amp;phone=13687654321&quot;</span> http://www.example.com/api<br><br><span class="hljs-comment"># POST请求 json传参 RequestBody</span><br>$ curl -v -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;captcha&quot;: &quot;abcd&quot;, &quot;phone&quot;: &quot;13687654321&quot;&#125;&#x27;</span> http://www.example.com/login<br><br>$ curl -v -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d @login.json http://www.example.com/login<br><br>$ <span class="hljs-built_in">cat</span> login.json<br>&#123;<br>  <span class="hljs-string">&quot;captcha&quot;</span>: <span class="hljs-string">&quot;abcd&quot;</span>,<br>  <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;13687654321&quot;</span><br>&#125;<br><br><span class="hljs-comment"># GET请求 发送OAuth2身份验证 PathVariable</span><br>curl -v -H <span class="hljs-string">&quot;Authorization: OAuth &lt;ACCESS_TOKEN&gt;&quot;</span> http://www.example.com/getInfo/&#123;<span class="hljs-built_in">id</span>&#125;<br><br><span class="hljs-comment"># POST请求 发送OAuth2身份验证 Content-Type: application/x-www-form-urlencoded</span><br>curl -v -H <span class="hljs-string">&quot;Authorization: OAuth &lt;ACCESS_TOKEN&gt;&quot;</span> -d <span class="hljs-string">&quot;username=yee&quot;</span> -d <span class="hljs-string">&quot;phone=13687654321&quot;</span>  http://www.example.com/user/list<br><br><span class="hljs-comment"># POST请求 发送OAuth2身份验证 json传参 RequestBody</span><br>curl -v -H <span class="hljs-string">&quot;Authorization: OAuth &lt;ACCESS_TOKEN&gt;&quot;</span> -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;username&quot;: &quot;yee&quot;, &quot;phone&quot;: &quot;13687654321&quot;, &quot;password&quot;: &quot;123456&quot;&#125;&#x27;</span> http://www.example.com/user/add<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Idea</title>
    <link href="/2023/09/04/rookie-Idea/"/>
    <url>/2023/09/04/rookie-Idea/</url>
    
    <content type="html"><![CDATA[<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><ul><li><p>Alt + Enter</p></li><li><p>Ctrl + Shift + A</p></li><li><p>Shift + Shift</p></li><li><p>Ctrl + N</p></li><li><p>Ctrl + Shift + N</p></li><li><p>Ctrl + Alt + Shift + N</p></li><li><p>Ctrl + 空格</p></li><li><p>Ctrl + Shift + 空格</p></li><li><p>Ctrl + Shift + Enter</p></li><li><p>Ctrl + W</p></li><li><p>Ctrl + Shift + W</p></li><li><p>Ctrl + D</p></li><li><p>Shift + ↑</p></li><li><p>Ctrl + Y</p></li><li><p>Alt + Shift + ↑</p></li><li><p>Ctrl + Shift + ↑</p></li><li><p>Ctrl + -</p></li><li><p>Ctrl + &#x3D;</p></li><li><p>Ctrl + Shift + -</p></li><li><p>Ctrl + Shift + &#x3D;</p></li><li><p>Ctrl + Alt + T</p></li><li><p>Ctrl + Shift + Delete</p></li><li><p>Alt + J</p></li><li><p>Alt + Shift + J</p></li><li><p>Ctrl + Alt + Shift + J</p></li><li><p>Ctrl + Alt + M</p></li><li><p>Ctrl + Alt + P</p></li><li><p>Ctrl + P</p></li><li><p>Refactor - F6</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Netty</title>
    <link href="/2023/09/01/rookie-Netty/"/>
    <url>/2023/09/01/rookie-Netty/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-什么是Netty"><a href="#1-1-什么是Netty" class="headerlink" title="1.1. 什么是Netty"></a>1.1. 什么是Netty</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Netty <span class="hljs-keyword">is</span> an asynchronous event-driven network <span class="hljs-built_in">application</span> framework<br><span class="hljs-keyword">for</span> rapid development <span class="hljs-keyword">of</span> maintainable high performance protocol servers &amp; clients.Copy<br></code></pre></td></tr></table></figure><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<font color='red'><code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></font></p><h2 id="1-2-Netty的优势"><a href="#1-2-Netty的优势" class="headerlink" title="1.2. Netty的优势"></a>1.2. Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li><p>需要自己构建协议</p></li><li><p>解决 TCP 传输问题，如粘包、半包</p></li><li><p>因为bug的存在，epoll 空轮询导致 CPU 100%</p></li></ul><p>Netty 对 API 进行增强，使之更易用，如</p><ul><li><p>FastThreadLocal -&gt; ThreadLocal</p></li><li><p>ByteBuf -&gt; ByteBuffer</p></li></ul><h2 id="1-3-Netty-的地位"><a href="#1-3-Netty-的地位" class="headerlink" title="1.3. Netty 的地位"></a>1.3. Netty 的地位</h2><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p><p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p><ul><li><p>Cassandra - nosql 数据库</p></li><li><p>Spark - 大数据分布式计算框架</p></li><li><p>Hadoop - 大数据分布式存储框架</p></li><li><p>RocketMQ - ali 开源的消息队列</p></li><li><p>ElasticSearch - 搜索引擎</p></li><li><p>gRPC - rpc 框架</p></li><li><p>Dubbo - rpc 框架</p></li><li><p>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</p></li><li><p>Zookeeper - 分布式协调框架</p></li></ul><h1 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2. 入门案例"></a>2. 入门案例</h1><h2 id="2-1-服务器端代码"><a href="#2-1-服务器端代码" class="headerlink" title="2.1. 服务器端代码"></a>2.1. 服务器端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 启动器 负责装配netty组件 启动服务器</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>            <span class="hljs-comment">// 2. 创建 NioEventLoopGroup 可以简单理解为 线程池 + Selector</span><br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>            <span class="hljs-comment">// 3. 选择 服务器的 ServerSocketChannel 实现</span><br>            .channel(NioServerSocketChannel.class)<br>            <span class="hljs-comment">// 4. child 负责处理读写 该方法决定了 child 执行哪些操作</span><br>            <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>            <span class="hljs-comment">// 它的作用是待客户端 SocketChannel 建立连接后 执行 initChannel 以便添加更多的处理器</span><br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-comment">// 5. SocketChannel 的处理器 使用 StringDecoder 解码 ByteBuf -&gt; String</span><br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                    <span class="hljs-comment">// 6. SocketChannel 的业务处理 使用上一个处理器的处理结果</span><br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            System.out.println(msg);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>                <span class="hljs-comment">// 7. ServerSocketChannel 绑定 8080 端口</span><br>            &#125;).bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2. 客户端代码"></a>2.2. 客户端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>            <span class="hljs-comment">// 1. 选择 客户端 Socket 实现类 NioSocketChannel 表示 基于 NIO 的客户端实现</span><br>            .channel(NioSocketChannel.class)<br>            <span class="hljs-comment">// 2. ChannelInitializer 处理器（仅执行一次）</span><br>            <span class="hljs-comment">// 它的作用是在客户端 SocketChannel 建立连接之后 执行 initChannel 添加更多的处理器</span><br>            .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-comment">// 3. 消息会经过管道中的 handler 处理 这里是将 String -&gt; ByteBuf 编码发出</span><br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                &#125;<br>                <span class="hljs-comment">// 4. 指定要连接的服务器和端口</span><br>            &#125;).connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>))<br>            <span class="hljs-comment">// 5. Netty 中很多方法都是异步的 如 connect</span><br>            <span class="hljs-comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span><br>            .sync()<br>            <span class="hljs-comment">// 6. 获取 channel 对象 它即为通道抽象 可以进行数据读写操作</span><br>            .channel()<br>            <span class="hljs-comment">// 7. 写入消息并清空缓冲区</span><br>            .writeAndFlush(<span class="hljs-string">&quot;hey!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-组件解释"><a href="#2-3-组件解释" class="headerlink" title="2.3. 组件解释"></a>2.3. 组件解释</h2><ul><li><p>channel 可以理解为数据的通道</p></li><li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p></li><li><p>handler 可以理解为数据的处理工序</p><ul><li><p>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler，handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p><ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li><p>handler 分 Inbound 和 Outbound 两类</p><ul><li><p>Inbound 入站</p></li><li><p>Outbound 出站</p></li></ul></li></ul></li><li><p>eventLoop 可以理解为处理数据的工人</p><ul><li><p>eventLoop 可以管理多个 channel 的 io 操作，并一旦 eventLoop 负责了某个 channel，就会将其与channel进行绑定，以后该 channel 中的 io 操作都由该 eventLoop 负责</p></li><li><p>eventLoop 既可以执行 io 操作，也可以进行任务处理，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</p></li><li><p>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</p></li></ul></li></ul><h1 id="3-粘包与半包"><a href="#3-粘包与半包" class="headerlink" title="3. 粘包与半包"></a>3. 粘包与半包</h1><h2 id="3-1-现象分析"><a href="#3-1-现象分析" class="headerlink" title="3.1. 现象分析"></a>3.1. 现象分析</h2><h3 id="3-1-1-粘包"><a href="#3-1-1-粘包" class="headerlink" title="3.1.1. 粘包"></a>3.1.1. 粘包</h3><ul><li><p>现象，发送 abc def，接收 abcdef</p></li><li><p>原因</p><ul><li><p>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</p></li><li><p>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</p></li><li><p>Nagle 算法：会造成粘包</p></li></ul></li></ul><h3 id="3-1-2-半包"><a href="#3-1-2-半包" class="headerlink" title="3.1.2. 半包"></a>3.1.2. 半包</h3><ul><li><p>现象，发送 abcdef，接收 abc def</p></li><li><p>原因</p><ul><li><p>应用层：接收方 ByteBuf 小于实际发送数据量</p></li><li><p>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</p></li><li><p>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</p></li></ul></li></ul><blockquote><p> 本质是因为 TCP 是流式协议，消息无边界</p></blockquote><h2 id="3-2-原理分析"><a href="#3-2-原理分析" class="headerlink" title="3.2. 原理分析"></a>3.2. 原理分析</h2><h3 id="3-2-1-滑动窗口"><a href="#3-2-1-滑动窗口" class="headerlink" title="3.2.1. 滑动窗口"></a>3.2.1. 滑动窗口</h3><ul><li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p><p><img src="/../img/0049.png" alt="0049"></p></li></ul><ul><li>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</li></ul><p><img src="/../img/0051.png" alt="0051"></p><ul><li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p><ul><li><p>图中深色的部分即要发送的数据，高亮的部分即窗口</p></li><li><p>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</p></li><li><p>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</p></li><li><p>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</p></li></ul></li></ul><h3 id="3-2-2-MSS-限制"><a href="#3-2-2-MSS-限制" class="headerlink" title="3.2.2. MSS 限制"></a>3.2.2. MSS 限制</h3><ul><li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p></li><li><p>以太网的 MTU 是 1500</p></li><li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p></li><li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p></li><li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 TCP 头和 IP 头后剩余能够作为数据传输的字节数</p></li><li><p>ipv4 TCP 头占用 20 bytes，IP 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460</p></li><li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p></li><li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p></li></ul><h3 id="3-2-3-Nagle-算法"><a href="#3-2-3-Nagle-算法" class="headerlink" title="3.2.3. Nagle 算法"></a>3.2.3. Nagle 算法</h3><ul><li><p>即使发送一个字节，也需要加入 TCP 头和 IP 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，TCP 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</p></li><li><p>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送</p><ul><li><p>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</p></li><li><p>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</p></li><li><p>如果 TCP_NODELAY &#x3D; true，则需要发送</p></li><li><p>已发送的数据都收到 ack 时，则需要发送</p></li><li><p>上述条件不满足，但发生超时（一般为 200ms）则需要发送</p></li><li><p>除上述情况，延迟发送</p></li></ul></li></ul><h2 id="3-3-解决方案"><a href="#3-3-解决方案" class="headerlink" title="3.3. 解决方案"></a>3.3. 解决方案</h2><ol><li><p>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</p></li><li><p>每一条消息采用固定长度，缺点浪费空间</p></li><li><p>每一条消息采用分隔符，例如 \n，缺点需要转义</p></li><li><p>每一条消息分为 head 和 body，head 中包含 body 的长度</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Redis</title>
    <link href="/2023/08/30/rookie-Redis/"/>
    <url>/2023/08/30/rookie-Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>Cache Aside Pattern是平时使用比较多的一个缓存读模式，比较适合读请求比较多的场景</p><p>Cache Aside Pattern中服务端需要同时维系数据库和缓存，并且是以数据库的结果为准</p><p>下面我们来看一下这个策略模式下的缓存读写步骤</p><p><strong>读策略</strong></p><ol><li><p>如果读取的数据命中了缓存，则直接返回数据</p></li><li><p>如果读取的数据没有命中缓存，则从数据库中读取数据</p></li><li><p>然后将数据写入到缓存，并且返回给用户</p></li></ol><p><strong>写策略</strong></p><ol><li><p>先更新数据库</p></li><li><p>删除缓存</p></li></ol><p>「先更新数据库，再删除缓存」的方案保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响</p><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li><p>缓存空值</p></li><li><p>布隆过滤器</p></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li><p>互斥锁</p></li><li><p>逻辑过期</p></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li>随机过期时间</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Git</title>
    <link href="/2023/08/25/rookie-Git/"/>
    <url>/2023/08/25/rookie-Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Quick-setup"><a href="#Quick-setup" class="headerlink" title="Quick setup"></a>Quick setup</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局配置用户名</span><br>$ git config --global user.name <span class="hljs-string">&quot;username&quot;</span><br><br><span class="hljs-comment"># 全局配置邮箱</span><br>$ git config --global user.email <span class="hljs-string">&quot;eamil@gmail.com&quot;</span><br><br><span class="hljs-comment"># 查看git配置信息</span><br>$ git config --list<br><br><span class="hljs-comment"># 查看git用户名</span><br>$ git config user.name<br><br><span class="hljs-comment"># 查看邮箱配置</span><br>$ git config user.email<br></code></pre></td></tr></table></figure><h1 id="GitHub-setup"><a href="#GitHub-setup" class="headerlink" title="GitHub setup"></a>GitHub setup</h1><p><strong>create a new repository on the command line</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# rookie&quot;</span> &gt;&gt; README.md<br><br>$ git init<br><br>$ git add README.md<br><br>$ git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br><br>$ git branch -M master<br><br>$ git remote add origin git@github.com:arloyee/rookie.git <br><br>$ git push -u origin master<br></code></pre></td></tr></table></figure><p><strong>…or push an existing repository from the command line</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:arloyee/rookie.git git branch -M master <br><br>$ git push -u origin master<br></code></pre></td></tr></table></figure><h1 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a>提交规范</h1><p><strong>主要type</strong></p><p><em>feat:  增加新功能</em><br><em>fix:    修复bug</em></p><p><strong>特殊type</strong></p><p><em>docs:       只改动了文档相关的内容</em><br><em>style:       不影响代码含义的改动，例如去掉空格、改变缩进、增删分号</em><br><em>build:      构造工具的或者外部依赖的改动，例如webpack，npm</em><br><em>refactor:  代码重构时使用</em><br><em>revert:    执行git revert打印的message</em></p><p><strong>暂不使用type</strong></p><p><em>test:       添加测试或者修改现有测试</em><br><em>perf:      提高性能的改动</em><br><em>ci:          与CI（持续集成服务）有关的改动</em><br><em>chore:   不修改src或者test的其他修改，例如构建过程或辅助工具的变动</em></p><h1 id="Pull-requests"><a href="#Pull-requests" class="headerlink" title="Pull requests"></a><a href="https://docs.github.com/pull-requests">Pull requests</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改最新的提交消息</span><br>$ git commit --amend<br><br><span class="hljs-comment"># 已将提交推送到 GitHub.com 强制推送含有修正消息的提交</span><br>$ git push --force-with-lease origin EXAMPLE-BRANCH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Spring</title>
    <link href="/2023/08/24/rookie-Spring/"/>
    <url>/2023/08/24/rookie-Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><h2 id="javax-validation-constraints"><a href="#javax-validation-constraints" class="headerlink" title="javax.validation.constraints"></a>javax.validation.constraints</h2><blockquote><p>JSR303&#x2F;JSR-349 标准</p></blockquote><h3 id="NotEmpty-NotBlank-NotNull"><a href="#NotEmpty-NotBlank-NotNull" class="headerlink" title="@NotEmpty, @NotBlank, @NotNull"></a>@NotEmpty, @NotBlank, @NotNull</h3><ul><li><p>@NotEmpty</p><p>The annotated element must not be null nor empty.<br>Supported types are:<br>CharSequence (length of character sequence is evaluated)<br>Collection (collection size is evaluated)<br>Map (map size is evaluated)<br>Array (array length is evaluated)</p></li><li><p>@NotBlank</p><p>The annotated element must not be null and must contain at least one non-whitespace character. Accepts CharSequence.</p></li><li><p>@NotNull</p><p>The annotated element must not be null. Accepts any type</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BUG-FIX</title>
    <link href="/2023/08/24/BUG-FIX/"/>
    <url>/2023/08/24/BUG-FIX/</url>
    
    <content type="html"><![CDATA[<h3 id="端口冲突"><a href="#端口冲突" class="headerlink" title="端口冲突"></a>端口冲突</h3><blockquote><p>Identify and stop the process that’s listening on port 8080 or configure this application to listen on another port.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># win 查看 java 进程</span><br>$ jps<br><br><span class="hljs-comment"># 查看端口状态</span><br>$ netstat 8080<br><br><span class="hljs-comment"># 查看占用端口的进程号</span><br>$ netstat -ano | findstr 8080<br><br><span class="hljs-comment"># 终止进程</span><br>$ taskkill /F /PID 8456<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Java</title>
    <link href="/2023/07/29/rookie-Java/"/>
    <url>/2023/07/29/rookie-Java/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><h3 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h3><p>在 Java 中，<code>BigDecimal</code> 类提供了 <code>divide</code> 方法用于执行除法运算。<code>divide</code> 方法有多个重载版本，可以用于执行不同类型的除法操作。</p><p>方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">divide</span><span class="hljs-params">(BigDecimal divisor)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>divisor</code>：除数，表示要将当前 <code>BigDecimal</code> 对象除以的值。</li></ul><p>方法返回值：</p><ul><li>返回一个新的 <code>BigDecimal</code> 对象，表示当前 <code>BigDecimal</code> 对象除以 <code>divisor</code> 后的结果。</li></ul><p>除了上述的简单版本，<code>BigDecimal</code> 的 <code>divide</code> 方法还有其他重载版本，可以用于指定除法运算的精度（小数位数）和舍入模式。以下是一个带有精度和舍入模式参数的重载版本：</p><p>方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">divide</span><span class="hljs-params">(BigDecimal divisor, <span class="hljs-type">int</span> scale, RoundingMode roundingMode)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>divisor</code>：除数，表示要将当前 <code>BigDecimal</code> 对象除以的值。</li><li><code>scale</code>：指定除法运算的精度，即结果的小数位数。</li><li><code>roundingMode</code>：舍入模式，用于处理除不尽的情况。</li></ul><p>方法返回值：</p><ul><li>返回一个新的 <code>BigDecimal</code> 对象，表示当前 <code>BigDecimal</code> 对象除以 <code>divisor</code> 后的结果，并根据指定的精度和舍入模式进行舍入。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10&quot;</span>);<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;3&quot;</span>);<br><br>    <span class="hljs-comment">// 简单的除法运算</span><br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> num1.divide(num2);<br>    System.out.println(result1); <span class="hljs-comment">// 输出：3.333333333333333333333333333333333333333333333333333333333333</span><br><br>    <span class="hljs-comment">// 指定精度和舍入模式的除法运算</span><br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> num1.divide(num2, <span class="hljs-number">2</span>, RoundingMode.HALF_UP);<br>    System.out.println(result2); <span class="hljs-comment">// 输出：3.33</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了两个 <code>BigDecimal</code> 对象 <code>num1</code> 和 <code>num2</code>，然后进行了除法运算。首先使用简单的 <code>divide</code> 方法进行除法运算，得到的结果是一个无限循环的小数。接着，我们使用带有精度和舍入模式参数的 <code>divide</code> 方法，将结果舍入到小数点后两位，得到了结果 “3.33”。可以看到，指定精度和舍入模式可以控制除法运算结果的精确度。</p><p>总结：<code>BigDecimal</code> 类的 <code>divide</code> 方法可以用于执行除法运算，并且提供了多个重载版本，以支持不同精度和舍入模式的除法计算。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><code>Map</code> 接口中的 <code>merge</code> 方法用于合并两个映射中的键值对。它可以用于向一个 Map 中添加新的键值对，或者更新已有键对应的值。</p><p>方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">merge</span><span class="hljs-params">(K key, V value, BiFunction&lt;? <span class="hljs-built_in">super</span> V, ? <span class="hljs-built_in">super</span> V, ? extends V&gt; remappingFunction)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p><code>key</code>： 要合并的键。</p></li><li><p><code>value</code>：要合并的值。</p></li><li><p><code>remappingFunction</code>：合并函数，用于处理重复的键值对。它是一个函数式接口 </p><p><code>BiFunction</code>，接受两个参数，并返回一个值。该函数接收两个参数：</p><ul><li><code>existingValue</code>：当前 Map 中与指定键关联的值（如果存在），如果键不存在则为 null。</li><li><code>newValue</code>：要合并的值。</li></ul></li></ul><p>方法返回值：</p><ul><li><p>方法返回合并后的值。如果指定的键在当前 Map 中不存在，或与指定键关联的值为 null，则将指定的键值对直接添加到当前 Map 中，并返回要合并的值。</p><p>如果指定的键在当前 Map 中存在，并且与指定键关联的值不为 null，则使用合并函数处理重复的键值对，并返回合并后的值。</p></li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Integer&gt; inventory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    inventory.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">productName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">additionalQuantity</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">// 合并新的库存量到 Map 中</span><br>    inventory.merge(productName, additionalQuantity,<br>        (existingQuantity, newQuantity) -&gt; existingQuantity + newQuantity);<br><br>    System.out.println(inventory); <span class="hljs-comment">// 输出：&#123;apple=30&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先创建了一个 <code>HashMap</code>，其中包含了产品名称和库存量的映射。接着，我们希望将新的库存量（20）合并到 Map 中的 “apple” 产品中。使用 <code>merge</code> 方法，我们找到 “apple” 对应的库存量（10），然后将新的库存量（20）与当前库存量相加得到 30，并将其更新到 Map 中。最终的结果是 <code>inventory</code> 中包含键值对 “apple&#x3D;30”。</p><p>这就是 <code>Map</code> 接口中 <code>merge</code> 方法的使用方法。它是一个很实用的方法，可以方便地处理 Map 中的键值对合并和更新操作。</p><h3 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault"></a>getOrDefault</h3><p><code>getOrDefault</code> 用于获取 Map 中指定键的值，如果键不存在于 Map 中，则返回一个默认值。</p><p>方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">getOrDefault</span><span class="hljs-params">(Object key, V defaultValue)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>key</code>：要获取值的键。</li><li><code>defaultValue</code>：如果键不存在时要返回的默认值。</li></ul><p>方法返回值：</p><ul><li>如果 <code>key</code> 存在于 <code>Map</code> 中，则返回与键关联的值。</li><li>如果 <code>key</code> 不存在于 <code>Map</code> 中，则返回默认值<code>defaultValue</code>。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 向 Map 中添加键值对</span><br>    map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">24</span>);<br>    map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 获取指定键的值，如果键不存在则返回默认值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> map.getOrDefault(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value3</span> <span class="hljs-operator">=</span> map.getOrDefault(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">0</span>);<br><br>    System.out.println(<span class="hljs-string">&quot;Value1: &quot;</span> + value1); <span class="hljs-comment">// 输出 24</span><br>    System.out.println(<span class="hljs-string">&quot;Value3: &quot;</span> + value3); <span class="hljs-comment">// 输出 0，因为 &quot;key3&quot; 不存在于 Map 中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，首先向 Map 中添加了两个键值对 (“key1”, 42) 和 (“key2”, 100)。然后使用 <code>getOrDefault</code> 方法来获取键 “key1” 的值，它存在于 Map 中，所以返回值为 42。接着尝试获取键 “key3” 的值，但由于 “key3” 不存在于 Map 中，所以返回默认值 0。</p><h3 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent"></a>computeIfPresent</h3><p><code>computeIfPresent</code> 方法用于根据指定的键和值更新 Map 中的值，但仅当键存在且对应的值非空时才进行更新。如果键不存在或对应的值为空，则不执行更新操作。</p><p>方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">computeIfPresent</span><span class="hljs-params">(K key, BiFunction&lt;? <span class="hljs-built_in">super</span> K,? <span class="hljs-built_in">super</span> V,? extends V&gt; remappingFunction)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>key</code> 表示要更新值的键。</li><li><code>remappingFunction</code> 是一个函数，接受两个参数：键 <code>K</code> 和当前键对应的值 <code>V</code>，并返回一个新的值 <code>V</code> 用于更新。</li></ul><p>方法返回值：</p><ul><li>如果 <code>key</code> 存在于 <code>Map</code> 中，且对应的值非空，根据 <code>remappingFunction</code> 函数计算生成新值，并返回新值。</li><li>如果 <code>key</code> 不存在于 <code>Map</code> 中，则返回 null。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 向 Map 中添加键值对</span><br>    map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">24</span>);<br>    map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 使用 computeIfPresent 方法更新键 &quot;key1&quot; 的值</span><br>    map.computeIfPresent(<span class="hljs-string">&quot;key1&quot;</span>, (key, value) -&gt; value + <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 使用 computeIfPresent 方法更新键 &quot;key3&quot; 的值（键 &quot;key3&quot; 不存在，不执行更新）</span><br>    map.computeIfPresent(<span class="hljs-string">&quot;key3&quot;</span>, (key, value) -&gt; value + <span class="hljs-number">10</span>);<br><br>    System.out.println(<span class="hljs-string">&quot;Value of key1: &quot;</span> + map.get(<span class="hljs-string">&quot;key1&quot;</span>)); <span class="hljs-comment">// 输出 34，因为更新了键 &quot;key1&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;Value of key3: &quot;</span> + map.get(<span class="hljs-string">&quot;key3&quot;</span>)); <span class="hljs-comment">// 输出 null，因为键 &quot;key3&quot; 不存在</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，首先向 Map 中添加了两个键值对 (“key1”, 24 和 (“key2”, 100)。然后使用 <code>computeIfPresent</code> 方法尝试更新键 “key1” 的值，因为 “key1” 存在于 Map 中，所以更新了值为 34。接着尝试更新键 “key3” 的值，但由于 “key3” 不存在于 Map 中，所以不执行更新操作。</p><h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h3><p><code>computeIfAbsent</code> 用于根据指定的键获取对应的值，如果键不存在，则通过一个函数计算生成新值并将其放入到 <code>Map</code> 中。</p><p>方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">computeIfAbsent</span><span class="hljs-params">(K key, Function&lt;? <span class="hljs-built_in">super</span> K, ? extends V&gt; mappingFunction)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>key</code>：要获取值的键。</li><li><code>mappingFunction</code>：生成新值的函数，它是一个函数式接口 <code>Function</code>，接受一个参数（即键 <code>key</code>），并返回生成的新值。</li></ul><p>方法返回值：</p><ul><li>如果 <code>key</code> 存在于 <code>Map</code> 中，则返回与键关联的值。</li><li>如果 <code>key</code> 不存在于 <code>Map</code> 中，则根据 <code>mappingFunction</code> 函数计算生成新值，并将新键值对添加到 <code>Map</code> 中，并返回新值。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Integer&gt; inventory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    inventory.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">productName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;banana&quot;</span>;<br><br>    <span class="hljs-comment">// 获取指定键对应的值，如果键不存在则使用函数生成新值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">quantity</span> <span class="hljs-operator">=</span> inventory.computeIfAbsent(productName, key -&gt; <span class="hljs-number">0</span>);<br><br>    System.out.println(inventory); <span class="hljs-comment">// 输出：&#123;apple=10, banana=0&#125;</span><br>    System.out.println(quantity); <span class="hljs-comment">// 输出：0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先创建了一个 <code>HashMap</code>，其中包含了产品名称和库存量的映射。接着，我们尝试使用 <code>computeIfAbsent</code> 方法获取键 “banana” 对应的值，由于该键不存在于 <code>inventory</code> 中，因此根据提供的 <code>mappingFunction</code> 函数计算生成新值 0，并将新的键值对 “banana&#x3D;0” 添加到 <code>inventory</code> 中，并返回新值 0。</p><p>注意，<code>computeIfAbsent</code> 方法在获取值时会检查键是否存在，如果键已存在，则不会执行 <code>mappingFunction</code> 函数。如果键不存在，则会执行 <code>mappingFunction</code> 函数生成新值并添加到 <code>Map</code> 中。</p><p>这就是 <code>Map</code> 接口中 <code>computeIfAbsent</code> 方法的使用方法。它非常方便，可以在需要根据键来生成新值并添加到 <code>Map</code> 中的场景中使用。</p><h3 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h3><p><code>putIfAbsent</code> 用于向 Map 中添加键值对，但仅当指定的键在 Map 中不存在时才执行添加操作。如果指定的键已经存在，方法不会执行添加操作，而是返回已存在的值。</p><p>方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">V <span class="hljs-title function_">putIfAbsent</span><span class="hljs-params">(K key, V value)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>key</code>：表示要添加的键。</li><li><code>value</code>：表示要添加的值。</li></ul><p>方法返回值：</p><ul><li>如果 <code>key</code> 存在于 <code>Map</code> 中，方法不会执行添加操作，返回已存在的值。</li><li>如果 <code>key</code> 不存在于 <code>Map</code> 中，则返回 null。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 添加键值对，如果键不存在</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> map.putIfAbsent(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">24</span>);<br>    System.out.println(<span class="hljs-string">&quot;Old Value: &quot;</span> + oldValue); <span class="hljs-comment">// 输出 null，表示添加成功</span><br><br>    <span class="hljs-comment">// 再次尝试添加相同的键值对</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">existingValue</span> <span class="hljs-operator">=</span> map.putIfAbsent(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">100</span>);<br>    System.out.println(<span class="hljs-string">&quot;Existing Value: &quot;</span> + existingValue); <span class="hljs-comment">// 输出 24，表示键已存在，不执行添加操作</span><br><br>    <span class="hljs-comment">// 查看最终结果</span><br>    System.out.println(<span class="hljs-string">&quot;Map: &quot;</span> + map); <span class="hljs-comment">// 输出：Map: &#123;key=24&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，首先尝试向 Map 中添加键值对 “key” 和 24，因为键 “key” 不存在，所以添加成功，返回值为 null。然后再次尝试添加相同的键值对，但由于键 “key” 已经存在，不执行添加操作，返回已存在的值 24。最终，Map 中只包含一个键值对 {key&#x3D;24}。</p><p>这个方法的主要目的是在多线程环境中避免竞态条件（race condition），确保只有一个线程成功地将键值对添加到 Map 中。</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h3 id="singletonList"><a href="#singletonList" class="headerlink" title="singletonList"></a>singletonList</h3><p><code>Collections</code> 类中的 <code>singletonList</code> 方法用于创建一个包含单个元素的不可变（immutable）列表（List）。这个列表只包含一个元素，长度固定为 1，因此无法对其进行添加或删除元素的操作。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 使用 singletonList 方法创建一个包含单个元素的不可变列表</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">singleElement</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>    List&lt;String&gt; list = Collections.singletonList(singleElement);<br><br>    <span class="hljs-comment">// 尝试修改列表内容，将会抛出 UnsupportedOperationException 异常</span><br>    <span class="hljs-comment">// list.add(&quot;World&quot;); // 试图修改不可变列表，抛出异常</span><br><br>    <span class="hljs-comment">// 访问列表元素</span><br>    System.out.println(<span class="hljs-string">&quot;List contains: &quot;</span> + list.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出: List contains: Hello</span><br>    System.out.println(<span class="hljs-string">&quot;List size: &quot;</span> + list.size()); <span class="hljs-comment">// 输出: List size: 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们首先使用 <code>singletonList</code> 方法创建一个包含单个元素 “Hello” 的不可变列表。由于该列表是不可变的，试图使用 <code>add</code> 方法添加元素 “World” 将会抛出 <code>UnsupportedOperationException</code> 异常。</p><p><code>singletonList</code> 方法在一些情况下非常有用，特别是当我们需要创建只包含一个元素的列表，并且希望保证列表内容不会被改变时。请注意，由于返回的列表是不可变的，因此在实际使用时，我们要确保不会对该列表进行修改操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rookie-Hexo</title>
    <link href="/2023/07/27/rookie-Hexo/"/>
    <url>/2023/07/27/rookie-Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清除缓存</span><br>$ hexo cl<br><br><span class="hljs-comment"># 生成静态文件</span><br>$ hexo g<br><br><span class="hljs-comment"># 运行本地服务</span><br>$ hexo s<br><br><span class="hljs-comment"># 部署到远程站点</span><br>$ hexo d<br></code></pre></td></tr></table></figure><h1 id="FIX"><a href="#FIX" class="headerlink" title="FIX"></a>FIX</h1><ul><li>FATAL Port 4000 has been used. Try other port instead.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 根据端口号查找对应的PID</span><br>$ netstat -ano | findstr 4000<br><br><span class="hljs-comment"># 根据PID找进程名称</span><br>$ tasklist | findstr 8860<br><br><span class="hljs-comment"># 根据PID结束对应进程</span><br>$ taskkill -PID 8860 -F<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
